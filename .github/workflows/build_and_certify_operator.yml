name: Build, Certify & Publish Operator

on:
  workflow_dispatch:
    inputs:
      operator_version:
        description: 'Operator version (e.g., 2.1.1-0-rc.0 or 2.1.1-0)'
        required: true
        type: string

defaults:
  run:
    shell: bash

jobs:
  build-certify-publish:
    runs-on: ubuntu-22.04
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          submodules: true

      - name: Update Submodules
        run: |
          git submodule update --init --recursive
          ls -la helm-charts/sumologic-kubernetes-collection/
          echo "âœ… Submodules updated"

      - name: Install Dependencies
        run: |
          pip install pyyaml
          sudo apt-get update && sudo apt-get install -y jq
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Detect Release Type
        id: detect
        run: |
          VERSION="${{ inputs.operator_version }}"
          
          if [[ "${VERSION}" =~ -rc[\.\-][0-9]+$ ]] || [[ "${VERSION}" =~ \.rc\.[0-9]+$ ]]; then
            RELEASE_TYPE="rc"
            IS_PRERELEASE="true"
          else
            RELEASE_TYPE="final"
            IS_PRERELEASE="false"
          fi
          
          echo "release_type=${RELEASE_TYPE}" >> $GITHUB_OUTPUT
          echo "is_prerelease=${IS_PRERELEASE}" >> $GITHUB_OUTPUT

      - name: Fetch Operator Project ID
        id: get_project_id
        run: |
          # Operator project ID from Red Hat Connect Portal
          PROJECT_ID="608aaab7ebd9cca472b09434"
          
          echo "project_id=${PROJECT_ID}" >> $GITHUB_OUTPUT
          echo "âœ… Operator Project ID: ${PROJECT_ID}"

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Operator Image
        run: |
          VERSION="${{ inputs.operator_version }}"
          RELEASE_NUMBER="1"
          
          docker build \
            --build-arg VERSION="${VERSION}" \
            --build-arg RELEASE_NUMBER="${RELEASE_NUMBER}" \
            -t "sumologic-operator:${VERSION}" \
            -f Dockerfile .
          
          echo "âœ… Image built with VERSION=${VERSION} RELEASE_NUMBER=${RELEASE_NUMBER}"

      - name: Fetch Quay.io Credentials
        id: quay_creds
        run: |
          PROJECT_ID="${{ steps.get_project_id.outputs.project_id }}"
          MAX_ATTEMPTS=10
          ATTEMPT=0

          echo "ðŸ”‘ Fetching Quay.io credentials from Red Hat API..."
          
          # Retry loop
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            RESPONSE=$(curl -sH "X-API-KEY: ${{ secrets.RED_HAT_API_KEY }}" \
              "https://catalog.redhat.com/api/containers/v1/projects/certification/id/${PROJECT_ID}/secrets")
            
            REGISTRY_PASSWORD=$(echo "${RESPONSE}" | jq -r '.registry_credentials.password // empty')
            REGISTRY_USERNAME=$(echo "${RESPONSE}" | jq -r '.registry_credentials.username // empty')
            DOCKER_CONFIG=$(echo "${RESPONSE}" | jq -r '.docker_config_json // empty')
            
            if [ -n "${REGISTRY_PASSWORD}" ] && [ "${REGISTRY_PASSWORD}" != "null" ]; then
              echo "registry_password=${REGISTRY_PASSWORD}" >> $GITHUB_OUTPUT
              echo "registry_username=${REGISTRY_USERNAME}" >> $GITHUB_OUTPUT

              # Save docker config
              mkdir -p ${HOME}/.docker
              echo "${DOCKER_CONFIG}" > ${HOME}/.docker/config.json
              
              echo "âœ… Quay.io credentials obtained"
              exit 0
            fi

            echo "âš ï¸ Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: Failed to get credentials, retrying in 3 seconds..."
            sleep 3
          done
          
          echo "âŒ Failed to obtain Quay.io credentials after ${MAX_ATTEMPTS} attempts"
          exit 1

      - name: Login to Quay.io
        run: |
          REGISTRY_USERNAME="${{ steps.quay_creds.outputs.registry_username }}"
          REGISTRY_PASSWORD="${{ steps.quay_creds.outputs.registry_password }}"
          
          echo "${REGISTRY_PASSWORD}" | \
            docker login -u "${REGISTRY_USERNAME}" quay.io --password-stdin
          
          echo "âœ… Logged in to Quay.io"
      
      - name: Push to Quay.io
        run: |
          VERSION="${{ inputs.operator_version }}"
          PROJECT_ID="${{ steps.get_project_id.outputs.project_id }}"

          QUAY_IMAGE="quay.io/redhat-isv-containers/${PROJECT_ID}:${VERSION}"
          
          docker tag "sumologic-operator:${VERSION}" "${QUAY_IMAGE}"
          docker push "${QUAY_IMAGE}"
          
          echo "quay_image=${QUAY_IMAGE}" >> $GITHUB_ENV
          echo "âœ… Image pushed to Quay.io"

      - name: Install Preflight
        run: |
          curl -Lo preflight https://github.com/redhat-openshift-ecosystem/openshift-preflight/releases/latest/download/preflight-linux-amd64
          chmod +x preflight
          sudo mv preflight /usr/local/bin/
      
      - name: Run Preflight Certification
        run: |
          PROJECT_ID="${{ steps.get_project_id.outputs.project_id }}"
          
          preflight check container "${quay_image}" \
            --submit \
            --pyxis-api-token="${{ secrets.RED_HAT_API_KEY }}" \
            --certification-component-id="${PROJECT_ID}" \
            --docker-config="${HOME}/.docker/config.json"
          
          echo "âœ… Certification submitted"
      
      - name: Wait for Certification
        id: wait_cert
        run: |
          VERSION="${{ inputs.operator_version }}"
          PROJECT_ID="${{ steps.get_project_id.outputs.project_id }}"
          MAX_ATTEMPTS=60
          ATTEMPT=0
          
          echo "â³ Waiting for certification (max 10 minutes)..."
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            
            # Query Pyxis API for image certification status
            RESPONSE=$(curl -sH "X-API-KEY: ${{ secrets.RED_HAT_API_KEY }}" \
              "https://catalog.redhat.com/api/containers/v1/projects/certification/id/${PROJECT_ID}/images?page_size=100")
            
            # Find the first certified image with matching tag
            DIGEST=$(echo "${RESPONSE}" | jq -r --arg VERSION "${VERSION}" \
              '[.data[] | select(.repositories[].tags[]?.name == $VERSION) | select(.certified == true)] | first | .docker_image_digest // empty')
            
            if [ -n "${DIGEST}" ] && [ "${DIGEST}" != "null" ]; then
              echo "âœ… Certified! Digest: ${DIGEST}"
              echo "certified=true" >> $GITHUB_OUTPUT
              echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "â³ Attempt ${ATTEMPT}/${MAX_ATTEMPTS}: Image not yet certified, waiting 10 seconds..."
            sleep 10
          done
          
          echo "âš ï¸ Certification pending after ${MAX_ATTEMPTS} attempts"
          echo "certified=false" >> $GITHUB_OUTPUT

      - name: Get Digest
        id: get_digest
        if: steps.wait_cert.outputs.certified == 'true'
        run: |
          VERSION="${{ inputs.operator_version }}"
          OPERATOR_NAME="sumologic-kubernetes-collection-helm-operator"
          DIGEST="${{ steps.wait_cert.outputs.digest }}"
          
          FULL_REF="registry.connect.redhat.com/sumologic/${OPERATOR_NAME}@${DIGEST}"
          
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "full_ref=${FULL_REF}" >> $GITHUB_OUTPUT
          echo "âœ… Full reference: ${FULL_REF}"

      - name: Update CSV
        if: steps.wait_cert.outputs.certified == 'true'
        run: |
          CSV_FILE="bundle/manifests/operator.clusterserviceversion.yaml"
          OPERATOR_NAME="sumologic-kubernetes-collection-helm-operator"
          FULL_REF="${{ steps.get_digest.outputs.full_ref }}"
          VERSION="${{ inputs.operator_version }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          BRANCH="update-digest-${VERSION}"
          git checkout -b "${BRANCH}"
          
          # Use sed to preserve file formatting (avoid yq reformatting issues)
          # Replace only digest-form operator image references (avoid tag substitutions)
          sed -i "s|registry.connect.redhat.com/sumologic/${OPERATOR_NAME}@sha256:[a-f0-9]\{64\}|${FULL_REF}|g" "${CSV_FILE}"
          
          # Also update bundle.yaml if it exists
          if [ -f "bundle.yaml" ]; then
            sed -i "s|registry.connect.redhat.com/sumologic/${OPERATOR_NAME}@sha256:[a-f0-9]\{64\}|${FULL_REF}|g" "bundle.yaml"
            git add bundle.yaml
          fi
          
          git add bundle/manifests/operator.clusterserviceversion.yaml
          git commit -m "chore: update operator image with certified digest for v${VERSION}"
          git push -u origin "${BRANCH}"
      
      - name: Create Digest PR
        id: digest_pr
        if: steps.wait_cert.outputs.certified == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ inputs.operator_version }}';
            const digest = '${{ steps.get_digest.outputs.digest }}';

            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `chore: update operator image with certified digest for v${version}`,
              head: `update-digest-${version}`,
              base: 'main',
              body: `Updates CSV with Red Hat certified digest.\n\n**Digest:** \`${digest}\`\n\nâš ï¸ **Manual review and merge required** - After merging, create a release tag and GitHub release manually.`
            });
            
            core.info(`âœ… PR created: #${pr.number}`);
            return pr.number;

      - name: Output Summary
        run: |
          VERSION="${{ inputs.operator_version }}"
          PROJECT_ID="${{ steps.get_project_id.outputs.project_id }}"
          CERTIFIED="${{ steps.wait_cert.outputs.certified }}"
          
          echo "## âœ… Operator Build & Certification Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** ${{ steps.detect.outputs.release_type }}" >> $GITHUB_STEP_SUMMARY
          echo "**Project ID:** ${PROJECT_ID}" >> $GITHUB_STEP_SUMMARY
          echo "**Certified:** ${CERTIFIED}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${CERTIFIED}" = "true" ]; then
            echo "### âœ… PR Created" >> $GITHUB_STEP_SUMMARY
            echo "A pull request has been created with the certified digest." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“‹ Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "1. Review and merge the digest update PR" >> $GITHUB_STEP_SUMMARY
            echo "2. Test the operator on OpenShift cluster" >> $GITHUB_STEP_SUMMARY
            echo "3. Create a git tag: \`git tag -a v${VERSION} -m 'Release v${VERSION}' && git push origin v${VERSION}\`" >> $GITHUB_STEP_SUMMARY
            echo "4. Create a GitHub release from the tag" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âš ï¸ Manual Steps Required" >> $GITHUB_STEP_SUMMARY
            echo "Certification pending. Once approved:" >> $GITHUB_STEP_SUMMARY
            echo "1. Manually update CSV with the certified digest" >> $GITHUB_STEP_SUMMARY
            echo "2. Create and merge a PR with the changes" >> $GITHUB_STEP_SUMMARY
            echo "3. Create a git tag and GitHub release" >> $GITHUB_STEP_SUMMARY
          fi
